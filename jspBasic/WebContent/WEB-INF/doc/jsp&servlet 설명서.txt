@WAS(Web Application Server) - Java Enterprise Edition Server

WAS는 Web Server + Application Server + Service의 의미다.
웹 서버는 Jsp/Servlet를 위한 웹 컨테이너와 HTML을 서비스하는 HTTP Server가
있다.
Application 서버는 비즈니스 로직을 수행하는 컨테이너가 있다
서비스는 JNDI, JMS와 같은 것을 제공하여 다른 기능의 서버와 연결하여
사용하게 하거나 서버 안에서 편리하게 사용할 수 있다

WAS에는 WebLogic, Zeus등 수많은 제품이 있다
Tomcat을 was라고 부르기도 한다

-클라이언트 서버 시스템 구조에서 서버 쪽 애플리케이션의 생성과 실행, 
소멸을 관리하는 프로그램을 애플리케이션 서버라 한다
서블릿과 서블릿 컨테이너와 같이 웹 기술을 기반으로 동작되는
애플리케이션 서버를 WAS라 부른다


@웹 컨테이너(Web Container)
웹 서버에는 HTML을 클라이언트로 보내는 HTTP 서버, jsp/servlet을 실행하는
엔진, 엔진과 jsp/servlet를 실행하는데 필요한 라이브러리등을 포함한
웹 컨테이너가 있다. 웹 프로그래밍에는 웹 컨테이너가 반드시 있어야 한다

@서블릿(Servlet)
서블릿은 컨테이너에서 실행되는 프로그램이다
요청에 대한 내용을 처리하고 결과를 HTML로 만든다
자바 코드로 구현한다

@JSP(Java Server Page)
자바 서버 페이지의 약자로 서버에서 실행되는 웹 프로그래밍용
클래스를 말한다
jsp로 된 파일은 서블릿으로 변환된다
jsp도 서블릿이므로 서블릿에서 사용하는 객체나 메서드를 jsp에서도
사용할 수 있다


@웹 프로젝트 폴더 구조
-src
자바 소스 파일을 두는 폴더
이 폴더에 서블릿 클래스나 필터, 리스너 등 필요한 모든
자바 클래스 파일을 둔다.

-build/classes
컴파일된 자바 클래스 파일(.class)이 놓이는 폴더이다
물론 패키지에 소속된 클래스인 경우 이 폴더에 해당 패키지가
자동으로 만들어진다

-WebContent
HTML(.html), CSS(.css), Javascript(.js), jsp, 이미지 파일 등
웹 컨텐츠를 두는 폴더이다
웹 애플리케이션을 서버에 배치할 때 이 폴더의 내용들이 그대로 복사된다

-WebContent/ WEB-INF
웹 애플리케이션의 설정과 관련된 파일을 두는 폴더이다
이 폴더에 있는 파일은 클라이언트에서 요청할 수 없다
따라서 html등의 클라이언트에서 요청할 파일을 이 폴더에 두어서는 안된다


-WebContent/ WEB-INF / web.xml
애플리케이션 배치 설명서(Deployment Descriptor) 파일이다. 
영어 포현으로는 줄여서 DD파일이라고도 부른다
서블릿이나 필터, 매개변수, 기본 웹 페이지 등 
웹 애플리케이션 컴포넌트들의 배치 정보를 이 파일에 작성한다
서블릿 컨테이너는 클라이언트의 요청을 처리할 때 이 파일의 정보를 참고하여
서블릿 클래스를 찾거나 필터를 수행하는 등의 작업을 수행한다
엄청나게 중요한 xml파일이다

-WebContent/ WEB-INF / lib
자바 아카이브 파일(.jar)을 두는 폴더이다


@서블릿의 라이프 사이클(Life Cycle)
웹 프로그래밍은 컨테이너가 반드시 필요하며
프로그래밍을 엔진에서 실행하여 원하는 결과를 생성한다

서블릿은 컨테이너의 명령에 따라 생성, 초기화, 실행, 소멸등
정해진 행동을 한다
이렇게 하는 것을 라이프 사이클이라고 한다
서블릿은 요청을 처음으로 받으면 서블릿을 생성한다

init -> service -> destroy를 호출하게 된다
일반적으로 init 메서드를 호출하여 service를 호출한다
서비스를 계속 수행하다 더 이상 요청이 없다면 destroy 메서드를 
호출하여 자원을 회수하고 서블릿 객체를 제거한다
컨테이너는 초기화와 소멸 메서드를 한 번만 호출한다


@ServletRequest
클라이언트의 요청 정보를 다룰 때 사용된다

 
@ServletResponse
응답과 관련된 기능을 제공한다
클라이언트에게 출력하는 내용에 해당하는 모든 정보들이 담겨 있다

JDBC(Java Database Connectivity)
프로그램과 DB를 연결하여 데이터를 주고 받을 수 있게 해주는 프로그래밍 인터페이스(API)

@HTTP 응답 상태 코드
stateCode		설명
200			요청이 성공적으로 처리됨
301			요청한 자원이 이동함, 헤더 정보에 이동 위치를 알려줄 테니 다시 요청바람
304			클라이언트가 임시 보관함 응답결과와 다르지 않다
400			잘못된 요청이다
404			요청한 자원을 못 찾았다
405			메서드 허용 안됨
500			서버 내부에서 오류가 발생했다

@Statement VS PreparedStatement
비교항목					statement					preparedStatement
실행속도				질의할 때마다 sql문을 컴파일한다		sql문을 미리 준비하여 컴파일해 둔다
												입력 매개변수 값만 추가하여 서버에
												전송한다. 특히 여러 번 반복하여 질의하는
												경우, 실행속도가 빠름
바이너리 데이터 전송		불가능						가능
프로그래밍 편의성			sql문 안에 입력 매개변수 값이		sql문과 입력 매개변수가 분리되어 있어서
					포함되어 있어서 sql문이 			코드 작성이 편리하다
					복잡하고 매개변수가 여러 개인
					경우 코드 관리가 힘들다
					보안이 안됨						보안이 됨


@GET VS POST 요청
GET 특징
-url에 데이터를 포함 -> 데이터 조회에 적합
-바이너리 및 대용량 데이터 전송 불가   
-요청라인과 헤드 필드의 최대 크기
	ㅁhttp사양에는 제한사항 없음
	ㅁ대용량 url로 인한 문제 발생 -> 웹 서버에 따라 최대 크기 제한
	

@get 요청을 발생시키는 방법
1. 웹 브라우저 주소창에 url을 입력하는 경우
2. 링크를 클릭하는 경우(a태그)
3. 입력 폼의 method 속성값이 get인 경우

@Get의 쓰임새
-자료를 검색한다거나, 게시글의 상세 정보를 본다거나, 특정 상품의 정보를 조회하는 것과
같이 데이터를 조회하는 경우에 적합하다
url에 검색어나 게시글 번호를 포함할 수 있기 때문에 메일이나 단문 메시지 등을 통해
다른 사람에게 전달하기가 쉽다
또한 즐겨 찾기에 저장해 두면 언제든지 해당 페이지로 바로 찾아갈 수 있어 매우 편리하다

@Get 단점
-보안에 좋지 않다 - 입력한 정보가 그대로 노출됨
로그인이나 개인정보 관리와 같은 보안을 요구하는 경우에는 get요청을 하지 말아야 한다

-바이너리 데이터 전송 불가
파일을 전송할 수 없다
이미지, 동영상등은 바이너리 파일이다
정보가 너무 크면 웹 서버에서 처리할 수 없기 때문에 바이너리를 전송하기에는 get은 적합하지 않다


@Post 특징
-url에 데이터가 포함되지 않음 -> 외부 노출 방지
-메시지 본문에 데이터 포함 -> 실행 결과 공유 불가
-바이너리 및 대용량 데이터 전송 가능

@post 장점
입력값을 url에 노출하지 않는다

@post 단점
요청 결과를 공유할 수 없다

@post 요청을 발생시키는 방법
1. 입력 폼의 method 속성값이 post인 경우

@post 쓰임새
로그인이나 결제정보와 같이 보안이 중요한 사항에 post를 사용
보내는 데이터의 크기 제한이 없어서 대용량 데이터들이 사용되는 곳에 사용

@TMI
get은 post보다 전송 속도가 빠르다


@컨텍스트(Context)
배포단위, 실행단위의 디렉토리를 컨텍스트라고 한다
jsp 프로젝트의 경우 일반적으로 WebContent가 해당



@필터(filter)
필터는 서블릿 실행 전후에 어떤 작업을 하고자 할 때 사용하는 기술이다
ex: 클라이언트가 보낸 데이터를 암호를 해제하거나
서블릿이 실행되기 전에 필요한 자원을 미리 준비한다거나
서블릿이 실행될 때마다 로그를 남긴다거나 등의 기타등등의
작업을 필터를 통해 처리할 수 있다

요청 -> 서블릿 컨테이너 -> 필터1 -> 필터2 -> 서블릿 
응답  <-			 <-		<-		 <-	
 


@Web History
-only servlet
계층구조
url mapping

-spagetti & separation(MVC 1ver)
view + viewLogic

scriptlet 
DTO


@MVC 이해하기
MVC(Model-View-Controller) 
아키텍처라고도 하며
모델, 뷰, 컨트롤러로 구분한다

-컨트롤러 컴포넌트의 역할
클라이언트 요청을 받았을 때 그 요청에 대해 실제 업무를 수행하는 모델 컴포턴트를 호출하는 일이다
또한 클라이언트가 보낸 데이터가 있다면, 모델을 호출할 때 전달하기 쉽게 데이터를 적절히
가공하는 일을 한다
모델이 업무 수행을 완료하면, 그 결과를 가지고 화면을 생성하도록 뷰에게 전달한다
즉 클라이언트 요청에 대해 모델과 뷰를 결정하여 전달하는 일을 한다
일종의 조정자라고 할 수 있다

-모델 컴포넌트 역할
데이터 저장소(데이터베이스, 디렉터리 서비스등)와 연동하여 사용자가 입력한 데이터나
사용자에게 출력할 데이터를 다루는 일을 한다
특히 여러 개의 데이터 변경 작업을 하나의 작업으로 묶은 트랜잭션을 다루는 일도 한다

-뷰 컴포넌트 역할
모델이 처리한 데이터나 그 작업 결과를 가지고 사용자에게 출력할 화면을 만드는 일을 한다
이렇게 생성된 화면은 웹 브라우저가 출력한다
즉 뷰는 HTML과 CSS, JavaScript를 사용하여 웹 브라우저가 출력할 UI를 만든다

@MVC 이점
-높은 재사용성, 넓은 융통성
쉽게 교체 가능
원 소스 멀티 유즈
코드 재사용

-빠른 개발, 저렴한 비용
다른 프로젝트에서도 모델을 재사용할 수 있다
소스 코드를 역할에 따라 나누었기 때문에 난이도에 따라 더 낮은 수준의 개발자와 협업이 가능하다

@MVC 구동 원리
컨트롤 요청 -> 요청 분석, 해결할 모델 찾아 실행 -> 모델은 쿼리를 실행하고 결과 얻음 ->
해당화면으로 이동하여 모델에서 얻은 데이터를 동적으로 처리(HTML로 렌더링) -> 브라우저에 화면 응답


@DTO(Data Transfer Object, 데이터 전송 객체)
데이터베이스 테이블에 해당하는 객체로 테이블의 컬럼들을 일대일로 저장할 수 있는 
멤버필드가 있고 get/set 패턴의 메서드를 갖는다
데이터베이스와 매우 밀접한 관련이 있는 객체이며 모델에 해당한다


@서블릿끼리 작업을 위임하는 방법
인클루딩

포워딩


