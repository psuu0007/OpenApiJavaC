@WAS(Web Application Server) - Java Enterprise Edition Server

WAS는 Web Server + Application Server + Service의 의미다.
웹 서버는 Jsp/Servlet를 위한 웹 컨테이너와 HTML을 서비스하는 HTTP Server가
있다.
Application 서버는 비즈니스 로직을 수행하는 컨테이너가 있다
서비스는 JNDI, JMS와 같은 것을 제공하여 다른 기능의 서버와 연결하여
사용하게 하거나 서버 안에서 편리하게 사용할 수 있다

WAS에는 WebLogic, Zeus등 수많은 제품이 있다
Tomcat을 was라고 부르기도 한다

-클라이언트 서버 시스템 구조에서 서버 쪽 애플리케이션의 생성과 실행, 
소멸을 관리하는 프로그램을 애플리케이션 서버라 한다
서블릿과 서블릿 컨테이너와 같이 웹 기술을 기반으로 동작되는
애플리케이션 서버를 WAS라 부른다


@웹 컨테이너(Web Container)
웹 서버에는 HTML을 클라이언트로 보내는 HTTP 서버, jsp/servlet을 실행하는
엔진, 엔진과 jsp/servlet를 실행하는데 필요한 라이브러리등을 포함한
웹 컨테이너가 있다. 웹 프로그래밍에는 웹 컨테이너가 반드시 있어야 한다

@서블릿(Servlet)
서블릿은 컨테이너에서 실행되는 프로그램이다
요청에 대한 내용을 처리하고 결과를 HTML로 만든다
자바 코드로 구현한다

@JSP(Java Server Page)
자바 서버 페이지의 약자로 서버에서 실행되는 웹 프로그래밍용
클래스를 말한다
jsp로 된 파일은 서블릿으로 변환된다
jsp도 서블릿이므로 서블릿에서 사용하는 객체나 메서드를 jsp에서도
사용할 수 있다


@웹 프로젝트 폴더 구조
-src
자바 소스 파일을 두는 폴더
이 폴더에 서블릿 클래스나 필터, 리스너 등 필요한 모든
자바 클래스 파일을 둔다.

-build/classes
컴파일된 자바 클래스 파일(.class)이 놓이는 폴더이다
물론 패키지에 소속된 클래스인 경우 이 폴더에 해당 패키지가
자동으로 만들어진다

-WebContent
HTML(.html), CSS(.css), Javascript(.js), jsp, 이미지 파일 등
웹 컨텐츠를 두는 폴더이다
웹 애플리케이션을 서버에 배치할 때 이 폴더의 내용들이 그대로 복사된다

-WebContent/ WEB-INF
웹 애플리케이션의 설정과 관련된 파일을 두는 폴더이다
이 폴더에 있는 파일은 클라이언트에서 요청할 수 없다
따라서 html등의 클라이언트에서 요청할 파일을 이 폴더에 두어서는 안된다


-WebContent/ WEB-INF / web.xml
애플리케이션 배치 설명서(Deployment Descriptor) 파일이다. 
영어 포현으로는 줄여서 DD파일이라고도 부른다
서블릿이나 필터, 매개변수, 기본 웹 페이지 등 
웹 애플리케이션 컴포넌트들의 배치 정보를 이 파일에 작성한다
서블릿 컨테이너는 클라이언트의 요청을 처리할 때 이 파일의 정보를 참고하여
서블릿 클래스를 찾거나 필터를 수행하는 등의 작업을 수행한다
엄청나게 중요한 xml파일이다

-WebContent/ WEB-INF / lib
자바 아카이브 파일(.jar)을 두는 폴더이다


@서블릿의 라이프 사이클(Life Cycle)
웹 프로그래밍은 컨테이너가 반드시 필요하며
프로그래밍을 엔진에서 실행하여 원하는 결과를 생성한다

서블릿은 컨테이너의 명령에 따라 생성, 초기화, 실행, 소멸등
정해진 행동을 한다
이렇게 하는 것을 라이프 사이클이라고 한다
서블릿은 요청을 처음으로 받으면 서블릿을 생성한다

init -> service -> destroy를 호출하게 된다
일반적으로 init 메서드를 호출하여 service를 호출한다
서비스를 계속 수행하다 더 이상 요청이 없다면 destroy 메서드를 
호출하여 자원을 회수하고 서블릿 객체를 제거한다
컨테이너는 초기화와 소멸 메서드를 한 번만 호출한다


@ServletRequest
클라이언트의 요청 정보를 다룰 때 사용된다

 
@ServletResponse
응답과 관련된 기능을 제공한다
클라이언트에게 출력하는 내용에 해당하는 모든 정보들이 담겨 있다

JDBC(Java Database Connectivity)
프로그램과 DB를 연결하여 데이터를 주고 받을 수 있게 해주는 프로그래밍 인터페이스(API)

@HTTP 응답 상태 코드
stateCode		설명
200			요청이 성공적으로 처리됨
301			요청한 자원이 이동함, 헤더 정보에 이동 위치를 알려줄 테니 다시 요청바람
304			클라이언트가 임시 보관함 응답결과와 다르지 않다
400			잘못된 요청이다
404			요청한 자원을 못 찾았다
405			메서드 허용 안됨
500			서버 내부에서 오류가 발생했다

@Statement VS PreparedStatement
비교항목					statement					preparedStatement
실행속도				질의할 때마다 sql문을 컴파일한다		sql문을 미리 준비하여 컴파일해 둔다
												입력 매개변수 값만 추가하여 서버에
												전송한다. 특히 여러 번 반복하여 질의하는
												경우, 실행속도가 빠름
바이너리 데이터 전송		불가능						가능
프로그래밍 편의성			sql문 안에 입력 매개변수 값이		sql문과 입력 매개변수가 분리되어 있어서
					포함되어 있어서 sql문이 			코드 작성이 편리하다
					복잡하고 매개변수가 여러 개인
					경우 코드 관리가 힘들다
					보안이 안됨						보안이 됨


@GET VS POST 요청
GET 특징
-url에 데이터를 포함 -> 데이터 조회에 적합
-바이너리 및 대용량 데이터 전송 불가   
-요청라인과 헤드 필드의 최대 크기
	ㅁhttp사양에는 제한사항 없음
	ㅁ대용량 url로 인한 문제 발생 -> 웹 서버에 따라 최대 크기 제한
	

@get 요청을 발생시키는 방법
1. 웹 브라우저 주소창에 url을 입력하는 경우
2. 링크를 클릭하는 경우(a태그)
3. 입력 폼의 method 속성값이 get인 경우

@Get의 쓰임새
-자료를 검색한다거나, 게시글의 상세 정보를 본다거나, 특정 상품의 정보를 조회하는 것과
같이 데이터를 조회하는 경우에 적합하다
url에 검색어나 게시글 번호를 포함할 수 있기 때문에 메일이나 단문 메시지 등을 통해
다른 사람에게 전달하기가 쉽다
또한 즐겨 찾기에 저장해 두면 언제든지 해당 페이지로 바로 찾아갈 수 있어 매우 편리하다

@Get 단점
-보안에 좋지 않다 - 입력한 정보가 그대로 노출됨
로그인이나 개인정보 관리와 같은 보안을 요구하는 경우에는 get요청을 하지 말아야 한다

-바이너리 데이터 전송 불가
파일을 전송할 수 없다
이미지, 동영상등은 바이너리 파일이다
정보가 너무 크면 웹 서버에서 처리할 수 없기 때문에 바이너리를 전송하기에는 get은 적합하지 않다


@Post 특징
-url에 데이터가 포함되지 않음 -> 외부 노출 방지
-메시지 본문에 데이터 포함 -> 실행 결과 공유 불가
-바이너리 및 대용량 데이터 전송 가능

@post 장점
입력값을 url에 노출하지 않는다

@post 단점
요청 결과를 공유할 수 없다

@post 요청을 발생시키는 방법
1. 입력 폼의 method 속성값이 post인 경우

@post 쓰임새
로그인이나 결제정보와 같이 보안이 중요한 사항에 post를 사용
보내는 데이터의 크기 제한이 없어서 대용량 데이터들이 사용되는 곳에 사용

@TMI
get은 post보다 전송 속도가 빠르다


@컨텍스트(Context)
배포단위, 실행단위의 디렉토리를 컨텍스트라고 한다
jsp 프로젝트의 경우 일반적으로 WebContent가 해당



@필터(filter)
필터는 서블릿 실행 전후에 어떤 작업을 하고자 할 때 사용하는 기술이다
ex: 클라이언트가 보낸 데이터를 암호를 해제하거나
서블릿이 실행되기 전에 필요한 자원을 미리 준비한다거나
서블릿이 실행될 때마다 로그를 남긴다거나 등의 기타등등의
작업을 필터를 통해 처리할 수 있다

요청 -> 서블릿 컨테이너 -> 필터1 -> 필터2 -> 서블릿 
응답  <-			 <-		<-		 <-	
 


@Web History
-only servlet
계층구조
url mapping

-spagetti & separation(MVC 1ver)
view + viewLogic

scriptlet 
DTO


@MVC 이해하기
MVC(Model-View-Controller) 
아키텍처라고도 하며
모델, 뷰, 컨트롤러로 구분한다

-컨트롤러 컴포넌트의 역할
클라이언트 요청을 받았을 때 그 요청에 대해 실제 업무를 수행하는 모델 컴포턴트를 호출하는 일이다
또한 클라이언트가 보낸 데이터가 있다면, 모델을 호출할 때 전달하기 쉽게 데이터를 적절히
가공하는 일을 한다
모델이 업무 수행을 완료하면, 그 결과를 가지고 화면을 생성하도록 뷰에게 전달한다
즉 클라이언트 요청에 대해 모델과 뷰를 결정하여 전달하는 일을 한다
일종의 조정자라고 할 수 있다

-모델 컴포넌트 역할
데이터 저장소(데이터베이스, 디렉터리 서비스등)와 연동하여 사용자가 입력한 데이터나
사용자에게 출력할 데이터를 다루는 일을 한다
특히 여러 개의 데이터 변경 작업을 하나의 작업으로 묶은 트랜잭션을 다루는 일도 한다

-뷰 컴포넌트 역할
모델이 처리한 데이터나 그 작업 결과를 가지고 사용자에게 출력할 화면을 만드는 일을 한다
이렇게 생성된 화면은 웹 브라우저가 출력한다
즉 뷰는 HTML과 CSS, JavaScript를 사용하여 웹 브라우저가 출력할 UI를 만든다

@MVC 이점
-높은 재사용성, 넓은 융통성
쉽게 교체 가능
원 소스 멀티 유즈
코드 재사용

-빠른 개발, 저렴한 비용
다른 프로젝트에서도 모델을 재사용할 수 있다
소스 코드를 역할에 따라 나누었기 때문에 난이도에 따라 더 낮은 수준의 개발자와 협업이 가능하다

@MVC 구동 원리
컨트롤 요청 -> 요청 분석, 해결할 모델 찾아 실행 -> 모델은 쿼리를 실행하고 결과 얻음 ->
해당화면으로 이동하여 모델에서 얻은 데이터를 동적으로 처리(HTML로 렌더링) -> 브라우저에 화면 응답


@DTO(Data Transfer Object, 데이터 전송 객체)
데이터베이스 테이블에 해당하는 객체로 테이블의 컬럼들을 일대일로 저장할 수 있는 
멤버필드가 있고 get/set 패턴의 메서드를 갖는다
데이터베이스와 매우 밀접한 관련이 있는 객체이며 모델에 해당한다


@서블릿끼리 작업을 위임하는 방법
인클루딩

포워딩


@데이터 보관소(객체 전달: Scope)
서블릿들이 서로 작업을 수행할 때 
데이터를 공유하는 방법을 말한다
서블릿 기술은 데이터를 공유하기 위한 방안으로 네 가지 종류의 
데이터 보관소를 제공한다

-ServletContext 레벨
웹 애플리케이션이 시작될 때 생성되어 웹 애플리케이션이 종료될 때 까지 유지된다
이 보관소에 데이터를 보관하면 웹 애플리케이션이 실행되는 동안에는 모든 서블릿이 
사용할 수 있다
jsp에서는 application 변수를 통해 이 보관소를 참조할 수 있다

-HttpSession 레벨
클라이언트의 최초 요청 시 생성되어 브라우저를 닫을 때까지 유지된다
보통 로그인할 때 이 보관소를 초기화하고, 로그아웃하면 이 보관소에 저장된 값들을 비운다
따라서 이 보관소에 값을 보관하면 서블릿이나 jsp페이지에 상관없이
로그아웃 하기 전까지 계속 값을 유지할 수 있다
jsp에서는 session 변수를 통해 참조할 수 있다

-ServletRequest 보관소
클라이언트의 요청이 들어올 때 생성되어, 클라이언트에게 응답할 때까지 유지된다
이 보관소는 포워딩이나 인클루딩하는 서블릿들 사이에서 값을 공유할 때 유용하다
jsp에서는 request 변수를 통해 참조할 수 있다

-JspContext 레벨
jsp 페이지를 실행하는 동안만 유지된다
jsp에서는 pageContext 변수를 통해 참조 가능하다

전달 객체를 다루는 방법은 전부 동일하다
전달 객체.setAttribute(키, 값);  	저장
전달 객체.getAttribute(키);			조회



@JSP 액션(Action) 태그(Tag)

jsp 페이지를 작성할 때, 가능한 자바 코드의 작성을 최소화하는 것이 
유지보수에 좋다

이를 위해 jsp에서는 다양한 jsp전용 태그를 제공하고 있다
jsp에서 기본으로 제공하는 태그들의 집합을 jsp action이라 한다

jsp 액션 태그를 사용하면 자바로 직접 코딩하는 것보다 빠르고 쉽게 원하는 기능을 작성할 수 있다
대박인건 유효성 검증 기술이 다 적용되어 있다
자바 코드를 분리하면 화면에 오류가 있어도 오류가 뜨지않으니 화면단 전문가의 
도움을 받을 수 있다

-useBean: 자바 인스턴스를 준비한다
인스턴스를 꺼내거나 객체를 새로 만들어 보관소에 저장하는 코드를 생성한다
자바 인스턴스를 jsp/servlet에서는 자바 빈(Java Bean)이라고 부른다

-include: 정적, 동적 자원을 인클루딩 하는 자바 코드를 생성한다

-forward: 현재 페이지의 실행을 멈추고 다른 정적, 동적 자원으로 포워딩한다

setProperty
getProperty도 있다 이들은 겟터/셋터 메서드를 호출한다

등등많다
 
@useBean 문법 표현식
<jsp:useBean 
	id="이름"
	scope="page || request || session || application"
	class="클래스명"
	type="타입명"
/>

-id속성: 객체의 이름을 설정
id를 통해 값을 꺼낼 수 있다 혹은 객체를 생성할 수도 있다

-scope속성: 기존의 객체를 조회하거나 새로 만든 객체를 저장할 보관소를 지정한다

-class속성: 자바 객체를 사용할 때 사용할 클래스 이름을 지정한다
무조건 패키지 이름을 포함한 풀 네임 스페이스를 작성해야 한다
인터페이스는 안된다
scope에 지정된 보관소에서 객체를 찾지 못하면 이 속성의 클래스 이름을 
사용하여 객체를 생성한다

-type속성: 참조 변수를 선언할 때 사용할 타입의 이름이다
클래스 이름이나 인터페이스 이름은 반드시 패키지 이름을 포함해야 한다
만약 이 속성의 값을 지정하지 않으면 class 속성의 값과 같다



@EL(Expression Language)
콤마와 대괄호를 사용하여 자바 빈의 프로퍼티나 맵, 리스트, 배열의 값을 
보다 쉽게 꺼내게 해주는 기술이다
JSP에서는 주로 보관소에 들어 있는 값을 꺼낼 때 사용한다
EL 표기법을 사용하면 액션 태그를 사용하는 것보다 훨씬 더 간단히 보관소에 들어 있는
객체에 접근하여 값을 꺼내거나 메서드를 호출할 수 있다


@EL 표기법
EL은 ${}와 #{}를 사용하여 값을 표현한다
${표현식}으로 지정된 값은 jsp가 실행될 때 jsp 페이지에 즉시 반영한다
#{표현식}으로 지정된 값은 시스템에서 필요하다고 판단될 때 그 값을 사용한다
#{}은 객체 프로퍼티의 값을 꺼내기보다는, 사용자가 입력한 값을 객체의 프로퍼티에 
담는 용도로 많이 사용한다

#{}은 일반 개발자가 사용하지 않으니 이런 표현도 있다 정도만 알고 넘어가자

중요한 건 $표기법이다

표현식 예
${member.no}
${객체이름.인스턴스변수명}
인스턴스변수명은 아니고 get의 이름이다(메서드명)

일반적으로 EL표기법은 명시하지 않으면 아래와 같은 순으로 자동적으로 빈을 찾는다
-탐색 순서
JspContext -> ServletRequest -> HttpSession -> ServletContext -> null


-EL에서 검색 범위 지정 방법
pageScope
requestScope
sessionScope
applicationScope

표현식 예
${sessionScope.member.no}
${sessionScope.studentDto.no}


@JSTL(JSP Standard Tag Library)
JSP 확장 태그 or jsp 표준 태그 라이브러리

JSTL은 JSP의 기본 태그가 아니므로 사용하려면 JSTL API 및 
이를 구현한 자바 라이브러리를 별도로 내려 받아야 한다

JSTL 태그를 이용하면 JSP 페이지에서 자바 코딩을 줄일 수 있다
이를 통해 웹 디자이너나 웹 퍼블리셔와의 공동 작업을 원활하게 진행할 수 있다

표준 태그를 사용하려면 그 태그의 라이브러리를 선언해야 한다
@태그 라이브러리를 선언하는 문법 표현식
<%@ taglib uri="사용할 태그의 라이브러리 URI" prefix="접두사" %>

<%@ taglib %>는 JSP의 지시자 태그이다
uri속성은 태그 라이브러리의 네임스페이스 이름이다
prefix속성은 jstl태그를 사용할 때 태그 이름 앞에 붙일 접두사이다

-JSTL 개발사가 제안하는 접두사 이름
Core	c
XML		x
I18N	fmt
등등

c:forEach 태그
반복적인 작업을 정의할 때 사용한다

<c:forEach var="변수명" items="목록데이터" begin="시작인덱스" end="종료인덱스">
	내용들

</c:forEach>

-items 속성의 값으로 올 수 있는 것들
배열
util의 collection객체들 ex: list등
iterator 구현체
Map 구현체
등


@Dao(Data Access Object) 데이터 접근 객체
데이터베이스에 관련된 작업(CRUD)을 전문적으로 담당하는 객체다
DAO 안의 메서드는 모두 데이터베이스와 관련된 작업을 한다

완전하진 않지만 이제서야 MVC 아키텍쳐(패턴)를 구성한 것이다

서블릿으로 부터 분리해야 하는 기능은 화면, 데이터베이스와 연동하여
데이터를 처리하는 부분이다

데이터 처리를 전문으로 하는 객체를 DAO라고 부른다


























